<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI äº’å‹•å¼ç¨‹åºæµç¨‹ç•«å¸ƒ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            touch-action: none; /* ç¦ç”¨è§¸æ§çš„é è¨­è¡Œç‚ºï¼Œå¦‚é é¢æ»¾å‹• */
        }
        #text-editor {
            position: absolute; display: none; padding: 10px; border: 2px solid #3b82f6;
            border-radius: 8px; font-size: 16px; background-color: #f0f9ff;
            outline: none; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 100;
            min-width: 200px; min-height: 40px; resize: both;
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        canvas {
            cursor: grab; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        canvas:active { cursor: grabbing; }
        
        /* --- Gemini API åŠŸèƒ½ç›¸é—œæ¨£å¼ --- */
        .loader {
            width: 24px; height: 24px; border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6; border-radius: 50%;
            animation: spin 1s linear infinite; display: none; /* åˆå§‹éš±è— */
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #explanation-modal {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-4 space-y-4">

    <div class="w-full max-w-6xl text-center">
        <h1 class="text-3xl font-bold text-slate-800">âœ¨ AI äº’å‹•å¼ç¨‹åºæµç¨‹ç•«å¸ƒ</h1>
        <p class="text-slate-600 mt-2">
            æ“ä½œæç¤ºï¼š<span class="font-semibold">é»æ“Š</span>æ–¹å¡Šå¯é¸å–ï¼Œ<span class="font-semibold">æ‹–æ›³</span>ä¾†ç§»å‹•ï¼Œ<span class="font-semibold">é›™æ“Š</span>ä¾†ç·¨è¼¯ã€‚
        </p>
    </div>

    <!-- Gemini API åŠŸèƒ½å€ -->
    <div class="w-full max-w-6xl p-4 bg-white rounded-lg shadow-md">
        <div class="flex flex-col lg:flex-row items-start gap-4 mb-4">
            <div class="flex-grow w-full">
                <label for="goal-input" class="block text-sm font-medium text-slate-700 mb-1">è¼¸å…¥æ‚¨çš„ç›®æ¨™æˆ–ä¸Šå‚³åœ–ç‰‡ï¼š</label>
                <input type="text" id="goal-input" placeholder="ä¾‹å¦‚ï¼šé–‹ç™¼ä¸€å€‹é›»å•†ç¶²ç«™ï¼Œæˆ–ä¸Šå‚³è¨­è¨ˆåœ–ç‰‡" class="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2">
                
                <!-- åœ–ç‰‡ä¸Šå‚³å€åŸŸ -->
                <div class="border-2 border-dashed border-gray-300 rounded-md p-4 text-center bg-gray-50 hover:bg-gray-100 transition-colors">
                    <input type="file" id="image-upload" accept="image/*" class="hidden">
                    <div id="upload-area" class="cursor-pointer">
                        <div id="upload-placeholder">
                            ğŸ“¸ <span class="text-gray-600">é»æ“Šä¸Šå‚³åœ–ç‰‡æˆ–æ‹–æ‹½åˆ°æ­¤è™•</span><br>
                            <span class="text-sm text-gray-500">æ”¯æ´ JPG, PNG, GIF ç­‰æ ¼å¼</span>
                        </div>
                        <div id="image-preview" class="hidden mt-2">
                            <img id="preview-img" class="max-w-full max-h-48 rounded-md mx-auto">
                            <button id="remove-image" class="mt-2 px-3 py-1 bg-red-500 text-white text-sm rounded-md hover:bg-red-600">ç§»é™¤åœ–ç‰‡</button>
                        </div>
                    </div>
                </div>
            </div>
            <button id="generate-steps-btn" class="w-full lg:w-auto bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors flex items-center justify-center gap-2">
                <div id="generate-loader" class="loader"></div>
                <span>âœ¨ ç”Ÿæˆæµç¨‹æ­¥é©Ÿ</span>
            </button>
        </div>
        
        <div class="flex flex-wrap gap-2">
            <div id="ai-controls" class="hidden">
                <button id="explain-step-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700 transition-colors flex items-center gap-2">
                    <div id="explain-loader" class="loader"></div>
                    <span>âœ¨ è§£é‡‹æ­¤æ­¥é©Ÿ</span>
                </button>
                <button id="delete-step-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-md hover:bg-red-700 transition-colors">
                    ğŸ—‘ï¸ åˆªé™¤æ­¥é©Ÿ
                </button>
                <button id="export-to-editor-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-md hover:bg-purple-700 transition-colors">
                    ğŸ“ åŒ¯å‡ºåˆ°ç·¨è¼¯å€
                </button>
            </div>
            <button id="add-step-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700 transition-colors">
                â• æ‰‹å‹•æ–°å¢æ­¥é©Ÿ
            </button>
            <button id="toggle-layout-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-md hover:bg-purple-700 transition-colors">
                ğŸŒ³ åˆ‡æ›æ¨¹ç‹€åœ–
            </button>
            <button id="clear-canvas-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-700 transition-colors">
                ğŸ§¹ æ¸…ç†Canvas
            </button>
        </div>
    </div>

    <!-- ç•«å¸ƒå’Œæ–‡å­—ç·¨è¼¯å™¨å®¹å™¨ -->
    <div class="flex w-full bg-white rounded-lg shadow-lg relative" style="min-height: 600px; max-height: 80vh;">
        <!-- å·¦é‚ŠCanvaså€åŸŸ (2/3) -->
        <div id="canvas-container" class="w-2/3 relative" style="border: 1px solid #e2e8f0; border-right: none; overflow: auto;">
            <canvas id="interactiveCanvas" style="display: block; margin: 0 auto;"></canvas>
        </div>
        
        <!-- å³é‚Šæ–‡å­—ç·¨è¼¯å€åŸŸ (1/3) -->
        <div id="text-editor-container" class="w-1/3 bg-gray-50 p-4 border border-l-0 border-gray-200 flex flex-col">
            <h3 class="text-lg font-semibold text-gray-800 mb-3">ğŸ“ æ–‡å­—ç·¨è¼¯å€</h3>
            <textarea id="document-editor" class="flex-1 w-full p-3 border border-gray-300 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="åœ¨é€™è£¡ç·¨è¼¯æ–‡å­—å…§å®¹..."></textarea>
            <div class="flex gap-2 mt-3">
                <button id="save-txt-btn" class="flex-1 bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                    ğŸ’¾ å„²å­˜ç‚º TXT
                </button>
                <button id="save-md-btn" class="flex-1 bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700 transition-colors">
                    ğŸ“„ å„²å­˜ç‚º MD
                </button>
            </div>
        </div>
    </div>

    <!-- æ–‡å­—ç·¨è¼¯å™¨ -->
    <textarea id="text-editor" placeholder="ç·¨è¼¯å…§å®¹..."></textarea>
    
    <!-- è§£é‡‹å½ˆå‡ºè¦–çª— -->
    <div id="explanation-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="text-lg font-bold text-slate-800">âœ¨ AI æ­¥é©Ÿè©³è§£</h3>
                <div class="flex gap-2">
                    <button id="copy-explanation-btn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded-md hover:bg-blue-600">è¤‡è£½</button>
                    <button id="close-modal-btn" class="text-slate-500 hover:text-slate-800">&times;</button>
                </div>
            </div>
            <div id="explanation-content" class="p-6 overflow-y-auto">
                <p>æ­£åœ¨å‘ Gemini è«‹æ±‚è§£é‡‹...</p>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM å…ƒç´ ç²å– ---
            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('interactiveCanvas');
            const ctx = canvas.getContext('2d');
            const textEditor = document.getElementById('text-editor');
            const documentEditor = document.getElementById('document-editor');
            const saveTxtBtn = document.getElementById('save-txt-btn');
            const saveMdBtn = document.getElementById('save-md-btn');
            const goalInput = document.getElementById('goal-input');
            const generateBtn = document.getElementById('generate-steps-btn');
            const imageUpload = document.getElementById('image-upload');
            const uploadArea = document.getElementById('upload-area');
            const uploadPlaceholder = document.getElementById('upload-placeholder');
            const imagePreview = document.getElementById('image-preview');
            const previewImg = document.getElementById('preview-img');
            const removeImageBtn = document.getElementById('remove-image');
            const explainBtn = document.getElementById('explain-step-btn');
            const addStepBtn = document.getElementById('add-step-btn');
            const toggleLayoutBtn = document.getElementById('toggle-layout-btn');
            const clearCanvasBtn = document.getElementById('clear-canvas-btn');
            const deleteStepBtn = document.getElementById('delete-step-btn');
            const exportToEditorBtn = document.getElementById('export-to-editor-btn');
            const aiControls = document.getElementById('ai-controls');
            const generateLoader = document.getElementById('generate-loader');
            const explainLoader = document.getElementById('explain-loader');
            const modal = document.getElementById('explanation-modal');
            const modalContent = document.getElementById('explanation-content');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const copyExplanationBtn = document.getElementById('copy-explanation-btn');

            // --- ç‹€æ…‹è®Šæ•¸ ---
            let items = [];
            let draggingItem = null;
            let selectedItem = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let currentTexts = [];
            let isInitialState = true; // æ–°å¢ï¼šç”¨æ–¼åˆ¤æ–·æ˜¯å¦ç‚ºåˆå§‹ç‹€æ…‹
            let isTreeLayout = false; // æ–°å¢ï¼šæ¨¹ç‹€åœ–æ¨¡å¼
            let uploadedImage = null; // æ–°å¢ï¼šå„²å­˜ä¸Šå‚³çš„åœ–ç‰‡
            const apiKey = "YOUR_GEMINI_API_KEY_HERE"; // è«‹æ›¿æ›ç‚ºæ‚¨çš„å¯¦éš› API Key

            // --- åˆå§‹åŒ–å‡½å¼ ---
            function init() {
                if (apiKey === "YOUR_GEMINI_API_KEY_HERE" || !apiKey || apiKey.trim() === '') {
                    const userKey = prompt("è«‹è¼¸å…¥æ‚¨çš„ Gemini API Key:");
                    if (!userKey || userKey.trim() === '') {
                        alert("éœ€è¦æœ‰æ•ˆçš„ Gemini API Key æ‰èƒ½ä½¿ç”¨ AI åŠŸèƒ½ã€‚è«‹é‡æ–°è¼‰å…¥é é¢ä¸¦è¼¸å…¥æœ‰æ•ˆçš„ Keyã€‚");
                        return;
                    }
                    window.apiKey = userKey;
                } else {
                    window.apiKey = apiKey;
                }
                currentTexts = ["é»æ“Šä¸Šæ–¹æŒ‰éˆ•ï¼Œè®“ AI ç‚ºæ‚¨ç”Ÿæˆæµç¨‹åœ–ï¼"];
                isInitialState = true;
                resizeCanvas(); 
                addEventListeners();
            }
            
            // --- è§£æè‡ªç„¶èªè¨€æ­¥é©Ÿ ---
            function parseNaturalLanguageSteps(text) {
                const steps = [];
                
                // å˜—è©¦åŒ¹é…ç·¨è™Ÿæ ¼å¼ï¼š1. æ¨™é¡Œ, 2. æ¨™é¡Œ ç­‰
                const numberedPattern = /^\d+\.\s*(.+)$/gm;
                let match;
                while ((match = numberedPattern.exec(text)) !== null) {
                    steps.push(match[1].trim());
                }
                
                // å¦‚æœæ²’æœ‰æ‰¾åˆ°ç·¨è™Ÿæ ¼å¼ï¼Œå˜—è©¦å…¶ä»–æ ¼å¼
                if (steps.length === 0) {
                    // å˜—è©¦åŒ¹é…æ¨™é¡Œï¼šæè¿°æ ¼å¼
                    const titleDescPattern = /^(.+?)[:ï¼š](.+)$/gm;
                    while ((match = titleDescPattern.exec(text)) !== null) {
                        const title = match[1].trim();
                        const desc = match[2].trim();
                        if (title && desc) {
                            steps.push(`${title}: ${desc}`);
                        }
                    }
                }
                
                // å¦‚æœé‚„æ˜¯æ²’æœ‰ï¼Œåˆ†å‰²æˆæ®µè½
                if (steps.length === 0) {
                    const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
                    paragraphs.forEach(para => {
                        const trimmed = para.trim();
                        if (trimmed.length > 0) {
                            steps.push(trimmed);
                        }
                    });
                }
                
                return steps.slice(0, 10); // é™åˆ¶æœ€å¤š 10 å€‹æ­¥é©Ÿ
            }
            async function callGeminiAPI(prompt, isJson = false, imageData = null, retries = 3, delay = 1000) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${window.apiKey}`;
                
                const contents = [{ parts: [] }];
                
                // å¦‚æœæœ‰åœ–ç‰‡ï¼Œå…ˆæ·»åŠ åœ–ç‰‡
                if (imageData) {
                    contents[0].parts.push({
                        inline_data: {
                            mime_type: imageData.type,
                            data: imageData.data
                        }
                    });
                }
                
                // æ·»åŠ æ–‡å­—æç¤º
                contents[0].parts.push({ text: prompt });
                
                const payload = { contents };

                if (isJson) {
                    payload.generationConfig = {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                steps: { type: "ARRAY", items: { type: "STRING" } }
                            }
                        }
                    };
                }

                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP éŒ¯èª¤! ç‹€æ…‹: ${response.status}`);
                        }

                        const result = await response.json();
                        
                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts.length > 0) {
                            let fullContent = '';
                            
                            for (const part of result.candidates[0].content.parts) {
                                if (part.text) {
                                    fullContent += part.text;
                                } else if (part.inline_data) {
                                    // è™•ç†åœ–ç‰‡æ•¸æ“š
                                    const imageData = part.inline_data.data;
                                    const mimeType = part.inline_data.mime_type;
                                    const imageUrl = `data:${mimeType};base64,${imageData}`;
                                    fullContent += `<br><img src="${imageUrl}" alt="AIç”Ÿæˆçš„åœ–ç‰‡" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px;"><br>`;
                                }
                            }
                            
                            return fullContent;
                        } else {
                            throw new Error("å¾ API æ”¶åˆ°äº†ç„¡æ•ˆçš„å›æ‡‰æ ¼å¼ã€‚");
                        }
                    } catch (error) {
                        console.error(`API å‘¼å«å¤±æ•— (å˜—è©¦ ${i + 1}/${retries}):`, error);
                        if (i === retries - 1) {
                            return null; // æ‰€æœ‰é‡è©¦å‡å¤±æ•—
                        }
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i))); // Exponential backoff
                    }
                }
            }
            
            // --- åŠŸèƒ½ï¼šç”Ÿæˆæ­¥é©Ÿ ---
            async function handleGenerateSteps() {
                const goal = goalInput.value.trim();
                
                // æª¢æŸ¥æ˜¯å¦æœ‰è¼¸å…¥æˆ–åœ–ç‰‡
                if (!goal && !uploadedImage) {
                    alert("è«‹è¼¸å…¥ç›®æ¨™æè¿°æˆ–ä¸Šå‚³åœ–ç‰‡ï¼");
                    return;
                }
                
                setLoadingState(generateBtn, generateLoader, true);
                
                let prompt = "";
                let imageData = null;
                
                if (uploadedImage) {
                    // å¦‚æœæœ‰åœ–ç‰‡ï¼Œæº–å‚™åœ–ç‰‡æ•¸æ“š
                    imageData = {
                        type: uploadedImage.type,
                        data: uploadedImage.data
                    };
                    
                    if (goal) {
                        prompt = `è«‹åˆ†æé€™å¼µåœ–ç‰‡ï¼Œä¸¦æ ¹æ“šç”¨æˆ¶çš„éœ€æ±‚ã€Œ${goal}ã€ä¾†ç”Ÿæˆå…·é«”å¯åŸ·è¡Œçš„æ­¥é©Ÿåˆ—è¡¨ã€‚è«‹ç”Ÿæˆ 3-8 å€‹æ­¥é©Ÿï¼Œæ¯å€‹æ­¥é©Ÿç”¨ç·¨è™Ÿæ¨™ç¤ºï¼Œä¾‹å¦‚ï¼š1. æ­¥é©Ÿæ¨™é¡Œ 2. æ­¥é©Ÿæ¨™é¡Œç­‰ã€‚`;
                    } else {
                        prompt = `è«‹åˆ†æé€™å¼µåœ–ç‰‡ï¼Œä¸¦æ ¹æ“šåœ–ç‰‡å…§å®¹ç”Ÿæˆç›¸é—œçš„å°ˆæ¡ˆæµç¨‹æ­¥é©Ÿã€‚è«‹ç”Ÿæˆ 3-8 å€‹æ­¥é©Ÿï¼Œæ¯å€‹æ­¥é©Ÿç”¨ç·¨è™Ÿæ¨™ç¤ºï¼Œä¾‹å¦‚ï¼š1. æ­¥é©Ÿæ¨™é¡Œ 2. æ­¥é©Ÿæ¨™é¡Œç­‰ã€‚`;
                    }
                } else {
                    // åªæœ‰æ–‡å­—çš„æƒ…æ³
                    prompt = `è«‹å°‡ä»¥ä¸‹ä»»å‹™åˆ†è§£ç‚ºæ¸…æ™°ã€å¯åŸ·è¡Œçš„æ­¥é©Ÿåˆ—è¡¨ã€‚ä»»å‹™æ˜¯ï¼šã€Œ${goal}ã€ã€‚è«‹ç”Ÿæˆ 3-8 å€‹æ­¥é©Ÿï¼Œæ¯å€‹æ­¥é©Ÿç”¨ç·¨è™Ÿæ¨™ç¤ºï¼Œä¾‹å¦‚ï¼š1. æ­¥é©Ÿæ¨™é¡Œ 2. æ­¥é©Ÿæ¨™é¡Œç­‰ã€‚`;
                }
                
                const resultText = await callGeminiAPI(prompt, false, imageData); // ç§»é™¤ JSON æ ¼å¼è¦æ±‚
                if (resultText) {
                    // ç›´æ¥ä½¿ç”¨è‡ªç„¶èªè¨€è§£æ
                    const steps = parseNaturalLanguageSteps(resultText);
                    if (steps.length > 0) {
                        isInitialState = false;
                        currentTexts = steps;
                        createItems(currentTexts);
                    } else {
                        alert("ç„¡æ³•è§£æ AI å›æ‡‰ï¼Œè«‹é‡è©¦ã€‚");
                    }
                } else {
                    alert("ç„¡æ³•å¾ AI ç²å–æ­¥é©Ÿï¼Œè«‹æª¢æŸ¥æ‚¨çš„ç¶²è·¯æˆ–ç¨å¾Œå†è©¦ã€‚");
                }
                setLoadingState(generateBtn, generateLoader, false);
            }

            // --- åŠŸèƒ½ï¼šè§£é‡‹æ­¥é©Ÿ ---
            async function handleExplainStep() {
                if (!selectedItem) return;
                
                setLoadingState(explainBtn, explainLoader, true);
                showModal("æ­£åœ¨å‘ Gemini è«‹æ±‚è§£é‡‹...");

                const prompt = `ä½œç‚ºä¸€åè³‡æ·±æŠ€è¡“å°å¸«ï¼Œè«‹è©³ç´°è§£é‡‹ä»¥ä¸‹è»Ÿé«”é–‹ç™¼æˆ–å°ˆæ¡ˆç®¡ç†ä¸­çš„æ­¥é©Ÿã€‚æ­¥é©Ÿæ˜¯ï¼šã€Œ${selectedItem.text}ã€ã€‚

è«‹æä¾›ï¼š
1. é€™æ˜¯ä»€éº¼çš„è©³ç´°è§£é‡‹
2. ç‚ºä»€éº¼å®ƒå¾ˆé‡è¦
3. å¦‚æœéœ€è¦è¦–è¦ºåŒ–èªªæ˜ï¼Œè«‹ç”¨ä»¥ä¸‹æ–¹å¼ä¹‹ä¸€å‘ˆç¾ï¼š
   - ASCII artç°¡å–®åœ–è¡¨
   - Mermaidåœ–è¡¨ä»£ç¢¼ï¼ˆæµç¨‹åœ–ã€æ™‚åºåœ–ç­‰ï¼‰
   - ç°¡å–®çš„æ–‡å­—åœ–ç¤º
   - ä»£ç¢¼ç¤ºä¾‹

è«‹ç”¨æ¸…æ™°æ˜“æ‡‚çš„æ–¹å¼å›ç­”ï¼Œä¸¦åœ¨é©ç•¶æ™‚æ©Ÿæä¾›è¦–è¦ºåŒ–èªªæ˜ã€‚`;
                
                const explanation = await callGeminiAPI(prompt);
                showModal(explanation || "æŠ±æ­‰ï¼Œç„¡æ³•ç²å–è§£é‡‹ã€‚è«‹ç¨å¾Œå†è©¦ã€‚");
                setLoadingState(explainBtn, explainLoader, false);
            }

            // --- åŠŸèƒ½ï¼šæ‰‹å‹•æ–°å¢æ­¥é©Ÿ ---
            function handleAddStep() {
                const newText = prompt("è«‹è¼¸å…¥æ–°çš„æ­¥é©Ÿå…§å®¹ï¼š");
                if (newText && newText.trim()) {
                    isInitialState = false;
                    currentTexts.push(newText.trim());
                    createItems(currentTexts);
                }
            }

            // --- åŠŸèƒ½ï¼šåˆ‡æ›ä½ˆå±€æ¨¡å¼ ---
            function handleToggleLayout() {
                isTreeLayout = !isTreeLayout;
                toggleLayoutBtn.textContent = isTreeLayout ? 'ğŸ“‹ åˆ‡æ›åˆ—è¡¨åœ–' : 'ğŸŒ³ åˆ‡æ›æ¨¹ç‹€åœ–';
                createItems(currentTexts);
            }

            // --- åŠŸèƒ½ï¼šæ¸…ç†Canvas ---
            function handleClearCanvas() {
                if (confirm('ç¢ºå®šè¦æ¸…ç†Canvaså—ï¼Ÿé€™å°‡æ¸…é™¤æ‰€æœ‰æ­¥é©Ÿã€‚')) {
                    items = [];
                    currentTexts = ["é»æ“Šä¸Šæ–¹æŒ‰éˆ•ï¼Œè®“ AI ç‚ºæ‚¨ç”Ÿæˆæµç¨‹åœ–ï¼"];
                    isInitialState = true;
                    selectedItem = null;
                    updateAIControls();
                    resizeCanvas();
                }
            }

            // --- åŠŸèƒ½ï¼šåˆªé™¤æ­¥é©Ÿ ---
            function handleDeleteStep() {
                if (!selectedItem) return;
                
                if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤æ­¥é©Ÿå—ï¼Ÿ')) {
                    // å¾currentTextsä¸­ç§»é™¤å°æ‡‰çš„æ–‡å­—
                    const index = currentTexts.findIndex(text => text === selectedItem.text);
                    if (index !== -1) {
                        currentTexts.splice(index, 1);
                    }
                    
                    // å¦‚æœæ²’æœ‰æ­¥é©Ÿäº†ï¼Œå›åˆ°åˆå§‹ç‹€æ…‹
                    if (currentTexts.length === 0) {
                        currentTexts = ["é»æ“Šä¸Šæ–¹æŒ‰éˆ•ï¼Œè®“ AI ç‚ºæ‚¨ç”Ÿæˆæµç¨‹åœ–ï¼"];
                        isInitialState = true;
                    }
                    
                    selectedItem = null;
                    updateAIControls();
                    createItems(currentTexts);
                }
            }

            // --- åŠŸèƒ½ï¼šå„²å­˜ç‚ºTXTæª”æ¡ˆ ---
            function handleSaveTxt() {
                const content = documentEditor.value;
                if (!content.trim()) {
                    alert('è«‹å…ˆè¼¸å…¥ä¸€äº›å…§å®¹å†å„²å­˜ï¼');
                    return;
                }
                
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'document.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- åŠŸèƒ½ï¼šå„²å­˜ç‚ºMDæª”æ¡ˆ ---
            function handleSaveMd() {
                const content = documentEditor.value;
                if (!content.trim()) {
                    alert('è«‹å…ˆè¼¸å…¥ä¸€äº›å…§å®¹å†å„²å­˜ï¼');
                    return;
                }
                
                const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'document.md';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- åŠŸèƒ½ï¼šåŒ¯å‡ºæ­¥é©Ÿåˆ°æ–‡å­—ç·¨è¼¯å€ ---
            function handleExportToEditor() {
                if (currentTexts.length === 0 || isInitialState) {
                    alert('æ²’æœ‰å¯åŒ¯å‡ºçš„æ­¥é©Ÿå…§å®¹ï¼');
                    return;
                }
                
                // å°‡æ‰€æœ‰æ­¥é©Ÿæ ¼å¼åŒ–ç‚ºæ–‡å­—
                let content = '# å°ˆæ¡ˆæµç¨‹æ­¥é©Ÿ\n\n';
                currentTexts.forEach((text, index) => {
                    content += `${index + 1}. ${text}\n\n`;
                });
                
                // å¦‚æœæœ‰é¸å–çš„æ­¥é©Ÿï¼Œæ·»åŠ è©³ç´°è³‡è¨Š
                if (selectedItem) {
                    content += `## ç•¶å‰é¸å–æ­¥é©Ÿ\n\n${selectedItem.text}\n\n`;
                }
                
                documentEditor.value = content;
            }

            // --- åœ–ç‰‡è™•ç†å‡½æ•¸ ---
            function handleImageUpload(file) {
                if (!file.type.startsWith('image/')) {
                    alert('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆï¼');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1]; // ç§»é™¤ data:image/...;base64,å‰ç¶´
                    
                    uploadedImage = {
                        file: file,
                        data: base64Data,
                        type: file.type,
                        name: file.name
                    };
                    
                    // é¡¯ç¤ºé è¦½
                    previewImg.src = e.target.result;
                    uploadPlaceholder.style.display = 'none';
                    imagePreview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }

            function removeImage() {
                uploadedImage = null;
                imagePreview.style.display = 'none';
                uploadPlaceholder.style.display = 'block';
                imageUpload.value = '';
            }

            function handleDragOver(e) {
                e.preventDefault();
                uploadArea.classList.add('bg-blue-50', 'border-blue-400');
            }

            function handleDragLeave(e) {
                e.preventDefault();
                uploadArea.classList.remove('bg-blue-50', 'border-blue-400');
            }

            function handleDrop(e) {
                e.preventDefault();
                uploadArea.classList.remove('bg-blue-50', 'border-blue-400');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleImageUpload(files[0]);
                }
            }

            // --- ç•«å¸ƒç›¸é—œå‡½å¼ ---
            function resizeCanvas() {
                // ç•¶è¦–çª—å¤§å°æ”¹è®Šæ™‚ï¼Œç¸½æ˜¯é‡æ–°è¨ˆç®—ä½ˆå±€
                if (currentTexts.length > 0) {
                    createItems(currentTexts);
                } else {
                    // èª¿æ•´å¯¬åº¦è¨ˆç®—ï¼Œå› ç‚ºç¾åœ¨canvaså®¹å™¨åªæœ‰2/3å¯¬åº¦
                    const containerWidth = canvasContainer.clientWidth;
                    canvas.width = Math.max(containerWidth - 40, 600); // æœ€å°å¯¬åº¦ 600px
                    canvas.height = 600; // å¢åŠ åˆå§‹é«˜åº¦
                    canvasContainer.style.height = '600px';
                    draw();
                }
            }

            function createItems(texts) {
                // **ä¿®æ­£ï¼šç¸½æ˜¯åœ¨ä½ˆå±€å‰æ›´æ–°ç•«å¸ƒå¯¬åº¦ï¼Œç¢ºä¿æœ€å°å¯¬åº¦**
                const containerWidth = canvasContainer.clientWidth;
                canvas.width = Math.max(containerWidth - 40, 600);
                ctx.font = '16px Inter';

                if (isInitialState && texts.length === 1) {
                    // åˆå§‹è¨Šæ¯çš„ç½®ä¸­é‚è¼¯
                    const text = texts[0];
                    const textMetrics = ctx.measureText(text);
                    const itemWidth = textMetrics.width + 40;
                    const itemHeight = 50;
                    
                    // **ä¿®æ­£ï¼šçµ¦åˆå§‹ç•«å¸ƒä¸€å€‹æ›´å¤§çš„é«˜åº¦**
                    canvas.height = 600; 
                    canvasContainer.style.height = `${canvas.height}px`;

                    let x = (canvas.width - itemWidth) / 2;
                    let y = (canvas.height / 2) - (itemHeight / 2);
                    
                    items = [{
                        id: Date.now(), text, x, y, width: itemWidth, height: itemHeight, isDragging: false
                    }];

                } else if (isTreeLayout) {
                    // æ¨¹ç‹€åœ–ä½ˆå±€é‚è¼¯
                    createTreeLayout(texts);
                } else {
                    // å‚ç›´æ’åˆ—ä½ˆå±€é‚è¼¯ï¼ˆæ¯å€‹é …ç›®ä½”ä¸€è¡Œï¼‰
                    createVerticalLayout(texts);
                }

                selectedItem = null;
                updateAIControls();
                draw();
            }

            function createVerticalLayout(texts) {
                const PADDING = 20;
                const GAP_Y = 20;
                const ITEM_HEIGHT = 60;
                const ITEM_WIDTH = Math.max(canvas.width - (PADDING * 2), 400);

                let currentY = PADDING;

                items = texts.map((text, index) => {
                    const lines = text.split('\n');
                    const actualHeight = Math.max(ITEM_HEIGHT, lines.length * 20 + 20);

                    const item = {
                        id: Date.now() + index,
                        text: text,
                        x: PADDING,
                        y: currentY,
                        width: ITEM_WIDTH,
                        height: actualHeight,
                        isDragging: false
                    };
                    
                    currentY += actualHeight + GAP_Y;
                    return item;
                });

                const requiredHeight = currentY + PADDING;
                canvas.height = Math.max(requiredHeight, 600);
                canvasContainer.style.height = `${canvas.height}px`;
            }

            function createTreeLayout(texts) {
                const PADDING = 50;
                const NODE_WIDTH = 180;
                const NODE_HEIGHT = 60;
                const HORIZONTAL_GAP = 50;
                const VERTICAL_GAP = 100;

                // å»ºç«‹æ›´æ¸…æ™°çš„æ¨¹ç‹€çµæ§‹
                const treeNodes = [];
                
                // ç¬¬ä¸€å±¤ï¼šæ ¹ç¯€é»
                if (texts.length > 0) {
                    treeNodes.push({
                        text: texts[0],
                        level: 0,
                        position: 0,
                        parent: null,
                        children: []
                    });
                }

                // ç¬¬äºŒå±¤ï¼šä¸»è¦åˆ†æ”¯
                if (texts.length > 1) {
                    const midPoint = Math.ceil((texts.length - 1) / 2);
                    
                    // å·¦åˆ†æ”¯
                    for (let i = 1; i <= midPoint && i < texts.length; i++) {
                        treeNodes.push({
                            text: texts[i],
                            level: 1,
                            position: i - 1,
                            parent: 0,
                            children: []
                        });
                    }
                    
                    // å³åˆ†æ”¯
                    for (let i = midPoint + 1; i < texts.length; i++) {
                        treeNodes.push({
                            text: texts[i],
                            level: 2,
                            position: i - midPoint - 1,
                            parent: 0,
                            children: []
                        });
                    }
                }

                // è¨ˆç®—ç•«å¸ƒå¤§å°
                const maxLevel = Math.max(...treeNodes.map(node => node.level));
                const maxNodesInLevel = Math.max(...Array.from({length: maxLevel + 1}, (_, level) => 
                    treeNodes.filter(node => node.level === level).length
                ));
                
                const canvasWidth = Math.max(canvas.width, (maxNodesInLevel * NODE_WIDTH) + ((maxNodesInLevel - 1) * HORIZONTAL_GAP) + (PADDING * 2));
                const canvasHeight = Math.max(600, ((maxLevel + 1) * NODE_HEIGHT) + (maxLevel * VERTICAL_GAP) + (PADDING * 2));
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                canvasContainer.style.height = `${canvasHeight}px`;

                // è¨ˆç®—æ¯å€‹ç¯€é»çš„ä½ç½®
                items = treeNodes.map((node, index) => {
                    const nodesInSameLevel = treeNodes.filter(n => n.level === node.level);
                    const levelWidth = (nodesInSameLevel.length - 1) * (NODE_WIDTH + HORIZONTAL_GAP);
                    const levelStartX = (canvas.width - levelWidth) / 2;
                    
                    const x = levelStartX + (node.position * (NODE_WIDTH + HORIZONTAL_GAP));
                    const y = PADDING + (node.level * (NODE_HEIGHT + VERTICAL_GAP));

                    return {
                        id: Date.now() + index,
                        text: node.text,
                        x: x,
                        y: y,
                        width: NODE_WIDTH,
                        height: NODE_HEIGHT,
                        isDragging: false,
                        level: node.level,
                        position: node.position,
                        parentIndex: node.parent,
                        nodeIndex: index
                    };
                });
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // å¦‚æœæ˜¯æ¨¹ç‹€åœ–ï¼Œå…ˆç¹ªè£½é€£æ¥ç·š
                if (isTreeLayout) {
                    drawTreeConnections();
                }

                items.forEach(item => {
                    ctx.save();
                    if (item.id === selectedItem?.id) { // ç¹ªè£½é¸å–ç‹€æ…‹
                        ctx.fillStyle = '#e0e7ff';
                        ctx.strokeStyle = '#4f46e5';
                        ctx.shadowColor = 'rgba(79, 70, 229, 0.4)';
                        ctx.shadowBlur = 12;
                    } else if (item.isDragging) { // ç¹ªè£½æ‹–æ›³ç‹€æ…‹
                        ctx.fillStyle = '#dbeafe';
                        ctx.strokeStyle = '#3b82f6';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 4;
                    } else {
                        ctx.fillStyle = isTreeLayout ? '#fef3c7' : '#f1f5f9'; // æ¨¹ç‹€åœ–ç”¨é»ƒè‰²èƒŒæ™¯
                        ctx.strokeStyle = isTreeLayout ? '#f59e0b' : '#cbd5e1'; // æ¨¹ç‹€åœ–ç”¨æ©™è‰²é‚Šæ¡†
                    }
                    
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(item.x, item.y, item.width, item.height, 8);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    ctx.fillStyle = '#1e293b';
                    ctx.font = isTreeLayout ? '14px Inter' : '16px Inter'; // æ¨¹ç‹€åœ–ç”¨è¼ƒå°å­—é«”
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // æ¨¹ç‹€åœ–é¡¯ç¤ºç¯€é»ç·¨è™Ÿ
                    if (isTreeLayout) {
                        // é¡¯ç¤ºç¯€é»ç·¨è™Ÿ
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px Inter';
                        ctx.fillText(`${item.nodeIndex + 1}`, item.x + item.width / 2, item.y - 5);
                        
                        // é¡¯ç¤ºç¯€é»å…§å®¹
                        ctx.fillStyle = '#1e293b';
                        ctx.font = '14px Inter';
                        const maxLength = 20;
                        const displayText = item.text.length > maxLength ? item.text.substring(0, maxLength) + '...' : item.text;
                        ctx.fillText(displayText, item.x + item.width / 2, item.y + item.height / 2);
                    } else {
                        // åˆ—è¡¨åœ–é¡¯ç¤ºå®Œæ•´å…§å®¹
                        const lines = item.text.split('\n');
                        const lineHeight = 20;
                        const startY = item.y + item.height / 2 - (lines.length - 1) * lineHeight / 2;
                        
                        lines.forEach((line, index) => {
                            const maxLength = 50;
                            const displayText = line.length > maxLength ? line.substring(0, maxLength) + '...' : line;
                            ctx.fillText(displayText, item.x + item.width / 2, startY + index * lineHeight);
                        });
                    }
                });
            }

            function drawTreeConnections() {
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                items.forEach((item, index) => {
                    if (item.parentIndex !== null && item.parentIndex !== undefined) {
                        const parent = items.find(i => i.nodeIndex === item.parentIndex);
                        if (parent) {
                            const parentX = parent.x + parent.width / 2;
                            const parentY = parent.y + parent.height;
                            const childX = item.x + item.width / 2;
                            const childY = item.y;

                            ctx.beginPath();
                            ctx.moveTo(parentX, parentY);
                            ctx.lineTo(parentX, parentY + (childY - parentY) / 2);
                            ctx.lineTo(childX, parentY + (childY - parentY) / 2);
                            ctx.lineTo(childX, childY);
                            ctx.stroke();
                        }
                    }
                });

                ctx.setLineDash([]);
            }

            function isMouseOverItem(x, y, item) {
                return x >= item.x && x <= item.x + item.width && y >= item.y && y <= item.y + item.height;
            }
            
            // --- äº‹ä»¶è™•ç† ---
            function handleMouseDown(e) {
                e.preventDefault();
                const { x, y } = getMousePos(e);
                let clickedOnItem = false;

                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    if (isMouseOverItem(x, y, item)) {
                        clickedOnItem = true;
                        selectedItem = item;
                        draggingItem = item;
                        item.isDragging = true;
                        dragOffsetX = x - item.x;
                        dragOffsetY = y - item.y;
                        
                        items.splice(i, 1);
                        items.push(item);
                        break;
                    }
                }
                
                if (!clickedOnItem) {
                    selectedItem = null;
                }
                
                updateAIControls();
                draw();
            }

            function handleMouseMove(e) {
                if (!draggingItem) return;
                e.preventDefault();
                const { x, y } = getMousePos(e);
                draggingItem.x = x - dragOffsetX;
                draggingItem.y = y - dragOffsetY;
                draw();
            }

            function handleMouseUp(e) {
                if (draggingItem) {
                    draggingItem.isDragging = false;
                    draggingItem = null;
                    draw();
                }
            }
            
            function handleDoubleClick(e) {
                const { x, y } = getMousePos(e);
                const clickedItem = items.find(item => isMouseOverItem(x, y, item));
                if (clickedItem) showTextEditor(clickedItem);
            }
            
            // --- UI è¼”åŠ©å‡½å¼ ---
            function showTextEditor(item) {
                const canvasRect = canvas.getBoundingClientRect();
                textEditor.style.display = 'block';
                textEditor.style.left = `${canvasRect.left + item.x}px`;
                textEditor.style.top = `${canvasRect.top + item.y}px`;
                textEditor.style.width = `${Math.max(item.width, 200)}px`;
                textEditor.style.height = `${Math.max(item.height, 40)}px`;
                textEditor.value = item.text;
                textEditor.focus();
                textEditor.select(); // é¸å–æ‰€æœ‰æ–‡å­—
                canvas.style.pointerEvents = 'none';
                
                const onFinishEditing = () => {
                    const newText = textEditor.value.trim();
                    if (newText) {
                        item.text = newText;
                        // é‡æ–°è¨ˆç®—é«˜åº¦ï¼Œæ”¯æ´å¤šè¡Œæ–‡å­—
                        const lines = newText.split('\n');
                        const actualHeight = Math.max(60, lines.length * 20 + 20);
                        item.height = actualHeight;
                        
                        // é‡æ–°ä½ˆå±€æ‰€æœ‰é …ç›®
                        createItems(currentTexts);
                        return; // æå‰è¿”å›ï¼Œå› ç‚º createItems æœƒé‡æ–°ç¹ªè£½
                    }
                    textEditor.style.display = 'none';
                    canvas.style.pointerEvents = 'auto';
                    draw();
                    textEditor.removeEventListener('blur', onFinishEditing);
                    textEditor.removeEventListener('keydown', onKeyDown);
                };
                
                const onKeyDown = (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        onFinishEditing();
                    } else if (event.key === 'Escape') {
                        textEditor.value = item.text;
                        onFinishEditing();
                    }
                };
                
                textEditor.addEventListener('blur', onFinishEditing);
                textEditor.addEventListener('keydown', onKeyDown);
            }
            
            function updateAIControls() {
                aiControls.style.display = selectedItem ? 'block' : 'none';
            }

            function setLoadingState(button, loader, isLoading) {
                button.disabled = isLoading;
                loader.style.display = isLoading ? 'inline-block' : 'none';
                button.style.cursor = isLoading ? 'not-allowed' : 'pointer';
            }
            
            function showModal(content) {
                // è™•ç†HTMLå…§å®¹ï¼ŒåŒ…æ‹¬å¯èƒ½çš„åœ–ç‰‡æ¨™ç±¤å’Œä»£ç¢¼å¡Š
                let processedContent = content.replace(/\n/g, '<br>');
                
                // è™•ç†ä»£ç¢¼å¡Š
                processedContent = processedContent.replace(/```(\w+)?\n?([\s\S]*?)```/g, (match, lang, code) => {
                    const language = lang || '';
                    const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `<div class="code-block" style="background: #f4f4f4; padding: 10px; border-radius: 5px; margin: 10px 0; font-family: monospace; white-space: pre-wrap;">${language ? '<div style="color: #666; font-size: 12px; margin-bottom: 5px;">' + language + '</div>' : ''}${escapedCode}</div>`;
                });
                
                // è™•ç†è¡Œå…§ä»£ç¢¼
                processedContent = processedContent.replace(/`([^`]+)`/g, '<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: monospace;">$1</code>');
                
                modalContent.innerHTML = processedContent;
                modal.classList.remove('opacity-0', 'pointer-events-none');
            }

            function hideModal() {
                modal.classList.add('opacity-0', 'pointer-events-none');
            }

            function copyExplanation() {
                const content = modalContent.textContent || modalContent.innerText;
                navigator.clipboard.writeText(content).then(() => {
                    // è‡¨æ™‚æ”¹è®ŠæŒ‰éˆ•æ–‡å­—è¡¨ç¤ºæˆåŠŸ
                    const originalText = copyExplanationBtn.textContent;
                    copyExplanationBtn.textContent = 'å·²è¤‡è£½ï¼';
                    copyExplanationBtn.style.backgroundColor = '#10b981';
                    setTimeout(() => {
                        copyExplanationBtn.textContent = originalText;
                        copyExplanationBtn.style.backgroundColor = '';
                    }, 2000);
                }).catch(err => {
                    console.error('è¤‡è£½å¤±æ•—:', err);
                    alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸å–æ–‡å­—è¤‡è£½');
                });
            }
            
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const event = e.touches ? e.touches[0] : e;
                return { x: event.clientX - rect.left, y: event.clientY - rect.top };
            }

            function addEventListeners() {
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mouseout', handleMouseUp);

                canvas.addEventListener('dblclick', handleDoubleClick);

                canvas.addEventListener('touchstart', handleMouseDown);
                canvas.addEventListener('touchmove', handleMouseMove);
                canvas.addEventListener('touchend', handleMouseUp);
                
                window.addEventListener('resize', resizeCanvas);

                generateBtn.addEventListener('click', handleGenerateSteps);
                explainBtn.addEventListener('click', handleExplainStep);
                addStepBtn.addEventListener('click', handleAddStep);
                toggleLayoutBtn.addEventListener('click', handleToggleLayout);
                clearCanvasBtn.addEventListener('click', handleClearCanvas);
                deleteStepBtn.addEventListener('click', handleDeleteStep);
                exportToEditorBtn.addEventListener('click', handleExportToEditor);
                saveTxtBtn.addEventListener('click', handleSaveTxt);
                saveMdBtn.addEventListener('click', handleSaveMd);
                
                // åœ–ç‰‡ä¸Šå‚³äº‹ä»¶
                uploadArea.addEventListener('click', () => imageUpload.click());
                imageUpload.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleImageUpload(e.target.files[0]);
                    }
                });
                removeImageBtn.addEventListener('click', removeImage);
                
                // æ‹–æ‹½äº‹ä»¶
                uploadArea.addEventListener('dragover', handleDragOver);
                uploadArea.addEventListener('dragleave', handleDragLeave);
                uploadArea.addEventListener('drop', handleDrop);
                
                closeModalBtn.addEventListener('click', hideModal);
                copyExplanationBtn.addEventListener('click', copyExplanation);
                modal.addEventListener('click', (e) => { if (e.target === modal) hideModal(); });
            }

            init();
        });
    </script>

</body>
</html>


